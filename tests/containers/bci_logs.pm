# SUSE's openQA tests
#
# Copyright 2022-2023 SUSE LLC
# SPDX-License-Identifier: FSFAP

# Summary: bci-tests log parser
#
#   This module is used to parse the result files generated by BCI-tests
#   tox commands.
#   BCI-tests produce separate XUnit results files for each environment.
#   This merges all files together into a single xml file that will
#   be used by OpenQA to represent the results in "External results"
# Maintainer: QE-C team <qa-c@suse.de>

use Mojo::Base 'opensusebasetest';
use XML::LibXML;
use testapi;
use serial_terminal 'select_serial_terminal';
use File::Basename;
use Data::Dumper;

sub run {
    select_serial_terminal;

    my $dom = XML::LibXML::Document->new('1.0', 'utf-8');
    my $root = $dom->createElement('testsuites');
    $dom->setDocumentElement($root);
    my $result_files = script_output('find /root/BCI-tests -maxdepth 2 -type f -name "junit_*.xml"');
    record_info('Files', $result_files);
    # Dump xml contents to a location where we can access later using data_url
    for my $file (split(/\n/, $result_files)) {
        # Each file will contain the engine as suffix, e.g. junit_minimal_docker.xml
        # We need to extract the container engine and the environment name
        (my $file_no_extension = $file) =~ s/.xml//;
        (my $file_no_prefix = $file_no_extension) =~ s/junit_*//;
        (my $env = $file_no_prefix) =~ s/\_.*//;
        (my $engine = $file_no_prefix) =~ s/.*\_//;
        my $log_file;
        eval {
            $log_file = upload_logs($file);
        };
        if ($@) {
            record_info('Skip', "Skipping results for $file. $@");
            next;
        }
        record_info('Parse', $log_file);
        my $dom = XML::LibXML->load_xml(location => "ulogs/$log_file");
        for my $ts ($dom->findnodes('//testsuite')) {
            # Replace default attribute name "pytest" by its env name and engine
            my $new_name = $env . '_' . $engine;
            $ts->{name} =~ s/pytest/$new_name/;
            my $softfailures = ($ts->{softfailures}) ? $ts->{softfailures} : 0;
            my $skipped = ($ts->{skipped}) ? $ts->{skipped} : 0;
            for my $tc ($ts->findnodes('./testcase')) {
                my $skippedNode = $tc->findnodes('./skipped[1]');
                next unless (scalar $skippedNode);
                my $node = $skippedNode->[0];
                next unless ($node->{type} eq 'pytest.xfail');
                my $message = $node->{type} . ': ' . $node->{message};
                my $softfailure = $dom->createElement('softfailure');
                $softfailure->setAttribute('message', $message);
                $tc->appendChild($softfailure);
                $tc->removeChild($node);
                $softfailures++;
                $skipped--;
            }
            $ts->{softfailures} = $softfailures;
            $ts->{skipped} = $skipped;
            # Append test results to the resulting xml file
            $root->appendChild($ts);
        }
    }
    $dom->toFile(hashed_string('result.xml'), 1);
    # Download file from host pool to the instance
    assert_script_run('curl -s ' . autoinst_url('/files/result.xml') . ' -o /tmp/result.txt');
    parse_extra_log('XUnit', '/tmp/result.txt');
}

1;

# SUSE's openQA tests
#
# Copyright 2021-2025 SUSE LLC
# SPDX-License-Identifier: FSFAP

# Summary: Test rootless mode on podman.
# - add a user on the /etc/subuid and /etc/subgid to allow automatically allocation subuid and subgid ranges.
# - check uids allocated to user (inside the container are mapped on the host)
# - give read access to the SUSE Customer Center credentials to call zypper from in the container.
#   This grants the current user the required access rights
# - Test rootless container:
#   * container is launched with default root user
#   * container is launched with existing user id
#   * container is launched with keep-id of the user who run the container
# - Restore /etc/zypp/credentials.d/ credentials
# Maintainer: QE-C team <qa-c@suse.de>

use Mojo::Base 'containers::basetest';
use testapi;
use serial_terminal 'select_serial_terminal';
use Utils::Systemd qw(systemctl);
use utils;
use containers::common;

my $quadlet_dir = '/etc/containers/systemd';

my $src_image = "registry.opensuse.org/opensuse/leap:15.6";
my $quadlet_container = <<_EOF_;
[Unit]
Description=The podmansh container
After=local-fs.target

[Container]
Image=$src_image
ContainerName=podmansh
UserNS=keep-id
RunInit=yes
DropCapability=all
NoNewPrivileges=true

# change homedir to match 'user-console' needle
Environment=HOME=/home
WorkingDir=/home

# OpenQA serial terminal access
AddDevice=/dev/ttyS0

Exec=sleep infinity

[Quadlet]
# avoid infinite waiting for network by podman-user-wait-network-online.service
# https://github.com/systemd/systemd/issues/28762
DefaultDependencies=false

[Install]
RequiredBy=default.target
_EOF_

my $unit_name = 'podmansh.container';
my $user;
my $uid;
my $systemd_user_path;
my $initial_user_shell;

sub run {
    my ($self) = @_;
    select_serial_terminal;

    my $podman = $self->containers_factory('podman');

    # prepare user for rootless containers
    prepare_rootless($self);

    install_packages('podmansh');

    # check quadlet works
    my $quadlet = '/usr/libexec/podman/quadlet';
    assert_script_run("$quadlet -version");

    # create user container
    assert_script_run("mkdir -p $systemd_user_path");
    assert_script_run(qq(printf "$quadlet_container" >"$systemd_user_path/$unit_name"));
    record_info('Unit', script_output("sudo -su $username $quadlet -user -v -dryrun"));

    # enable user linger
    assert_script_run("loginctl enable-linger $uid");

    $initial_user_shell = script_output(qq(getent passwd "$user" | cut -d':' -f7));
    assert_script_run(qq(usermod -s /usr/bin/podmansh "$user"));

    # prepare ssh key for passwordless login
    my $sshkeypath = "/root/.ssh/id_ed25519";
    if (script_run(qq(test -e "$sshkeypath.pub")) != 0) {
        assert_script_run(qq(ssh-keygen -t ed25519 -f "$sshkeypath" -q -N ""));
    }
    my $usersshpath = "/home/$user/.ssh";
    assert_script_run(qq(mkdir -p "$usersshpath" && chown "$user:$user" "$usersshpath"));
    assert_script_run(qq(tee -a "$usersshpath/authorized_keys" <"$sshkeypath.pub"));

    # pre-pull the image and make sure the service is running
    script_retry("sudo -su $username sh -c 'cd; podman pull $src_image'", retry => 3, delay => 60, timeout => 180);
    systemctl("--machine=$username@.host --user start podmansh");
    systemctl("--machine=$username@.host --user is-active podmansh");

    # change the dafault podmansh non-root shell to match 'text-logged-in-bernhard' needle
    assert_script_run(qq(sudo -su $user sh -c 'cd; mkdir -p ~/.config/containers/; printf '\\''[podmansh]\\nshell = \"/bin/bash\"\\n'\\'' > ~/.config/containers/containers.conf'));

    # validate podmansh container for multiple login methods
    my @cmds = (
        "sudo -iu $user sh -c",
        "su --login $user -c",
        "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -q $user\@localhost"
    );
    for my $cmd (@cmds) {
        execute_tests($cmd);
    }

    # Remove all previous commands generated by root. Some of these commands will be triggered
    # by the rootless user and will generate the same file /tmp/scriptX which will fail if it
    # already exists owned by root
    assert_script_run 'rm -rf /tmp/script*';
    ensure_serialdev_permissions;
    select_console "user-console";

    execute_tests("sh -c");
}

sub execute_tests {
    my $cmd = shift;
    validate_script_output("$cmd id", sub { /^uid=1000\(bernhard\) gid=1000\(bernhard\) groups=1000\(bernhard\)$/ });
    validate_script_output("$cmd 'cat /etc/os-release'", sub { /^VERSION=\"15\.6\"$/m && /^ID=\"opensuse-leap\"$/m });
}

sub prepare_rootless {
    my $self = shift;
    my $user = $testapi::username;

    # --- START borrowed from rootless_podman.pm ---
    # TODO: IS THIS REQUIRED?
    if (get_var('TDUP')) {
        my $cont_storage = '/etc/containers/storage.conf';
        my $local_storage = "/home/$user/.local";

        # use only packaged storage config in /usr/share/containers/storage.conf
        if (script_run("test -f $cont_storage &> /dev/null") == 0) {
            assert_script_run("rm -rf $cont_storage");
            assert_script_run('rm -rf /var/lib/containers/storage');
        }

        # prevent database graph driver mismatch
        if (script_run("test -d $local_storage &> /dev/null") == 0) {
            record_soft_failure('gh#containers/podman#24738');
            assert_script_run("rm -rf $local_storage");
        }

        assert_script_run('podman system reset -f');
    }

    # Some products don't have bernhard pre-defined (e.g. SLE Micro)
    if (script_run("grep $user /etc/passwd") != 0) {
        assert_script_run "useradd -m $user";
        assert_script_run "echo '$user:$testapi::password' | chpasswd";
        # Make sure user has access to tty group
        my $serial_group = script_output "stat -c %G /dev/$testapi::serialdev";
        assert_script_run "grep '^${serial_group}:.*:${user}\$' /etc/group || (chown $user /dev/$testapi::serialdev && gpasswd -a $user $serial_group)";
    }
    # --- END borrowed from rootless_podman.pm ---
}

sub pre_run_hook {
    $user = $testapi::username;
    $uid = script_output("id -u $user");
    $systemd_user_path = "$quadlet_dir/users/$uid";
}

sub cleanup {
    assert_script_run("loginctl disable-linger $uid");

    # TODO: kill user session

    script_run(qq(rm -f "$systemd_user_path/$unit_name"));
    script_run(qq(usermod -s "$initial_user_shell" "$user"));
    script_run(qq(rm -rf "/home/$user/.config/containers/"));
}

sub post_run_hook {
    select_serial_terminal;
    my $podman = shift->containers_factory('podman');
    $podman->cleanup_system_host();
    cleanup();
}

sub post_fail_hook {
    select_serial_terminal;
    my $podman = shift->containers_factory('podman');
    $podman->cleanup_system_host();
    cleanup();
}

1;

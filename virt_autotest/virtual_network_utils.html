<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>lib/virt_autotest/virtual_network_utils.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel='stylesheet' href='../style.css' />
</head>

<body>



<ul id="index"><li><a href="../index.html"><i>&lt;= Back to file list</i></a></li>
  <li>
    <ul>
      <li><a href="#get_vm_ip_with_nmap">get_vm_ip_with_nmap</a></li>
      <li><a href="#find_vm_primary_nic_info">find_vm_primary_nic_info</a></li>
      <li><a href="#config_domain_resolver">config_domain_resolver</a></li>
      <li><a href="#write_network_bridge_device_config">write_network_bridge_device_config</a></li>
      <li><a href="#write_network_bridge_device_ifcfg">write_network_bridge_device_ifcfg</a></li>
      <li><a href="#write_network_bridge_device_nmconnection">write_network_bridge_device_nmconnection</a></li>
      <li><a href="#activate_network_bridge_device">activate_network_bridge_device</a></li>
      <li><a href="#config_virtual_network_device">config_virtual_network_device</a></li>
      <li><a href="#check_guest_network_config">check_guest_network_config</a></li>
      <li><a href="#check_guest_network_address">check_guest_network_address</a></li>
      <li><a href="#config_network_device_policy">config_network_device_policy</a></li>
    </ul>
  </li>
</ul><h1>lib/virt_autotest/virtual_network_utils.pm</h1>

<h2 id="get_vm_ip_with_nmap">get_vm_ip_with_nmap</h2>

<pre><code>get_vm_ip_with_nmap(vm_name[, source =&gt; &#39;vm_vif_src&#39;])</code></pre>

<p>Query the IP of the VM via nmap. It allows to specify the source of the vif, to query IP for. If &#39;vm_vif_src&#39; is not provided, it will use the default one based on `find_vm_primary_nic_info`.</p>

<p>It supports all types of vif that we use in VT test, namely br0,br123,default/other vnet.</p>

<h2 id="find_vm_primary_nic_info">find_vm_primary_nic_info</h2>

<pre><code>find_vm_primary_nic_info(guest[, exclude_net =&gt; &#39;exclude_net&#39;])</code></pre>

<p>Find the guest&#39;s primary NIC type and source based on `virsh domiflist guest` output. Primary NIC is the one, before doing hotplugging or virtual network test. Based on our code logic, it will search from type bridge to type network. The first available one is the one.</p>

<p>Return: ($type, $source), eg (&#39;bridge&#39;, &#39;br123&#39;), (&#39;bridge&#39;, &#39;br0&#39;), (&#39;network&#39;, &#39;default&#39;)</p>

<h2 id="config_domain_resolver">config_domain_resolver</h2>

<p>Create domain resolver and prevent it from being overwritten automatically. Other arguments include domain resolver configuration file resolvconf, resolver address resolvip and domain name domainname.</p>

<h2 id="write_network_bridge_device_config">write_network_bridge_device_config</h2>

<pre><code>write_network_bridge_device_config(name =&gt; $name [, ipaddr =&gt; $ipaddr,
    bootproto =&gt; $bootproto, startmode =&gt; $startmode, zone =&gt; $zone,
    bridge_type =&gt; $bridge_type, _bridge_ports =&gt; $bridge_ports,
    bridge_stp =&gt; $bridge_stp, bridge_forwarddelay =&gt; $bridge_forwarddelay,
    backup_folder =&gt; $backup_folder])</code></pre>

<p>Write network device settings to conventional /etc/sysconfig/network/ifcfg-* or /etc/NetworkManager/system-connections/*.nmconnection depends on whether system network is managed by NetworkManager or not. The supported arguments are listed out as below: $ipaddr: IP address/mask length pair of the interface $name: Identifier of the interface $bootproto: DHCP automatic or manual configuration, &#39;static&#39;, &#39;dhcp&#39; or &#39;none&#39; $startmode: Auto start up or connection: &#39;auto&#39;, &#39;manual&#39; or &#39;off&#39; $zone: The trust level of this network connection $bridge_type: &#39;master&#39; or &#39;slave&#39; to indicate master or slave interface $bridge_port: Specify interface&#39;s master or slave interface name $bridge_stp: &#39;on&#39; or &#39;off&#39; to turn stp on or off $bridge_forwarddelay: The stp forwarding delay in seconds If $ipaddr given is empty, it means there is no associated specific ip address to this interface which might be attached to another bridge interface or will not be assigned one ip address from dhcp, so set $ipaddr to &#39;0.0.0.0&#39;.If $ipaddr given is non-empty but not in ip address format,for example, &#39;host&#39;,it means the interface will not use a ip address from pre-defined subnet and will automically accept dhcp ip address from public facing host network.</p>

<h2 id="write_network_bridge_device_ifcfg">write_network_bridge_device_ifcfg</h2>

<pre><code>write_network_bridge_device_ifcfg(name =&gt; $name [, ipaddr =&gt; $ipaddr,
    name =&gt; $name, bootproto =&gt; $bootproto, startmode =&gt; $startmode,
    zone =&gt; $zone, bridge_type =&gt; $bridge_type, bridge_ports =&gt; $bridge_ports,
    bridge_stp =&gt; $bridge_stp, bridge_forwarddelay =&gt; $bridge_forwarddelay,
    backup_folder =&gt; $backup_folder])</code></pre>

<p>Write bridge device config file to /etc/sysconfig/network/ifcfg-*. Please refer to https://github.com/openSUSE/sysconfig/blob/master/config/ifcfg.template for config file content. This subroutine is supposed to be used by calling subroutine write_network_bridge_device_config.</p>

<h2 id="write_network_bridge_device_nmconnection">write_network_bridge_device_nmconnection</h2>

<pre><code>write_network_bridge_device_nmconnection(name =&gt; $name [, ipaddr =&gt; $ipaddr,
    name =&gt; $name, bootproto =&gt; $bootproto, startmode =&gt; $startmode,
    zone =&gt; $zone, bridge_type =&gt; $bridge_type, bridge_ports =&gt; $bridge_ports,
    bridge_stp =&gt; $bridge_stp, bridge_forwarddelay =&gt; $bridge_forwarddelay,
    backup_folder =&gt; $backup_folder])</code></pre>

<p>Write bridge device config file to /etc/NetworkManager/system-connections/*. NM settings are a little bit different from ifcfg settings, but there are definite mapping between them. So translation from well-known and default ifcfg settings to NM settings is necessary. Please refer to nm-settings explanation as below: https://developer-old.gnome.org/NetworkManager/stable/nm-settings-keyfile.html. This subroutine is supposed to be used by calling write_network_bridge_device_config.</p>

<h2 id="activate_network_bridge_device">activate_network_bridge_device</h2>

<pre><code>activate_network_bridge_device(host_device =&gt; $host_device,
    bridge_device =&gt; $bridge_device, network_mode =&gt; $network_mode)</code></pre>

<p>Activate guest network bridge device by using wicked or NetworkManager depends on system configuration. And also validate whether activation is successful or not.</p>

<h2 id="config_virtual_network_device">config_virtual_network_device</h2>

<pre><code>config_virtual_network_device(driver =&gt; &#39;driver&#39;, transport =&gt; &#39;transport&#39;,
    user =&gt; &#39;user&#39;, host =&gt; &#39;host&#39;, port =&gt; &#39;port&#39;, path =&gt; &#39;path&#39;,
    extra =&gt; &#39;extra&#39;, fwdmode =&gt; &#39;fwdmode&#39;, name =&gt; &#39;name&#39;, device =&gt; &#39;device&#39;,
    ipaddr =&gt; &#39;ip&#39;, netmask =&gt; &#39;mask&#39;, startaddr =&gt; &#39;start&#39;, endaddr =&gt; &#39;end&#39;,
    domainname =&gt; &#39;domainname&#39;, confdir =&gt; &#39;confdir&#39;)</code></pre>

<p>Create virtual network to be used. This subroutine also calls construct_uri to determine the desired URI to be connected if the interested party is not localhost. Please refer to subroutine construct_uri for the arguments related. The network to be created based on arguments fwdmode, name, device, ipaddr, netmask, startaddr , endaddr and domainname. The configuration file is constructed from arguments name and confdir.</p>

<h2 id="check_guest_network_config">check_guest_network_config</h2>

<p>Check and obtain guest network configuration. Guest xml config contains enough information about network to which guest connects on boot, for example: &lt;interface type=&quot;network&quot;&gt; &lt;mac address=&quot;00:16:3e:4f:5a:35&quot;/&gt; &lt;source network=&quot;vn_nat_vbrXXX&quot;/&gt; &lt;/interface&gt; or &lt;interface type=&#39;bridge&#39;&gt; &lt;mac address=&#39;52:54:00:70:9d:b2&#39;/&gt; &lt;source bridge=&#39;br123&#39;/&gt; &lt;model type=&#39;virtio&#39;/&gt; &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x01&#39; slot=&#39;0x00&#39; function=&#39;0x0&#39;/&gt; &lt;/interface&gt; Interface type, source network/bridge name and model type are those useful ones determine the network, they will be stored in guest_matrix{guest}{nettype}, guest_matrix{guest}{netname} and guest_matrix{guest}{netmode}. In order to obtain netmode conveniently and consistently, netname should take the form of &quot;vn_&quot; + &quot;nat/route/host&quot; + &quot;_other_strings&quot; if virtual network to be used. Addtionally, guest_matrix{guest}{macaddr} is also upated by querying domiflist and ip address guest_matrix{guest}{ipaddr} can also be obtained from lib/virt_autotest/common.pm if static ip address is being used. The main arguments are guest to be checked and directory in which guest xml config is stored. This subroutine also calls construct_uri to determine the desired URI to be connected if the interested party is not localhost. Please refer to subroutine construct_uri for the arguments related. Argument guest specifies list of guests separated by space to be handled, matrix specifies address of guest matrix to be filled up after obtainsing information about a guest. If matrix is not specified, a local matrix address will be used and returned.</p>

<h2 id="check_guest_network_address">check_guest_network_address</h2>

<p>Check and obtain guest ip address. If static ip address is being used, there is no need to check it anymore. If guest uses bridge device directly, its ip address can be obtained by querying journal log or scanning subnet by using nmap (if host bridge device br0 is being used directly) with mac address. If guest uses virtual network created by virsh, its ip address can be obtained by querying dhcp leases of the virtual network or scanning subnet by using nmap (if host bridge device is being used in the virtual network directly) with mac address. The main arguments is guest to be checked. This subroutine also calls construct_uri to determine the desired URI to be connected if the interested party is not localhost. Please refer to subroutine construct_uri for the arguments related. Argument guest specifies list of guests separated by space to be handled, matrix specifies address of guest matrix to be filled up after obtainsing information about a guest. If matrix is not specified, a local matrix address will be used and returned.</p>

<h2 id="config_network_device_policy">config_network_device_policy</h2>

<pre><code>config_network_device_policy(logdir =&gt; &#39;folder path&#39;, name =&gt; &#39;distiguish name&#39;,
    netdev =&gt; &#39;network device&#39;)</code></pre>

<p>Stop firewall/apparmor, loosen iptables rules and enable forwarding globally and on all default route devices and netdev. Please specify logdir in which applied rules will be stored, name which will be appened to form distinguish scirpt name and netdev to be concerned.</p>


</body>

</html>



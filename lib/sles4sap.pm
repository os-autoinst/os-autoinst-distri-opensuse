## no critic (RequireFilenameMatchesPackage);
package sles4sap;
use base "opensusebasetest";

use strict;
use warnings;
use testapi;
use utils;
use hacluster 'pre_run_hook';
use isotovideo;
use ipmi_backend_utils;
use x11utils 'ensure_unlocked_desktop';
use power_action_utils 'power_action';
use Utils::Backends 'use_ssh_serial_console';

our @EXPORT = qw(
  ensure_serialdev_permissions_for_sap
  fix_path
  set_ps_cmd
  set_sap_info
  user_change
  reset_user_change
  get_total_mem
  prepare_profile
  copy_media
  add_hostname_to_hosts
  test_pids_max
  test_forkbomb
  test_version_info
  test_instance_properties
  test_stop
  test_start
  reboot
);

our $prev_console;
our $sapadmin;
our $sid;
our $instance;
our $ps_cmd;

=head2 ensure_serialdev_permissions_for_sap

Derived from 'ensure_serialdev_permissions' function available in 'utils'.

Grant user permission to access serial port immediately as well as persisting
over reboots. Used to ensure that testapi calls like script_run work for the
test user as well as root.
=cut
sub ensure_serialdev_permissions_for_sap {
    my ($self) = @_;
    # ownership has effect immediately, group change is for effect after
    # reboot an alternative https://superuser.com/a/609141/327890 would need
    # handling of optional sudo password prompt within the exec
    my $serial_group = script_output "stat -c %G /dev/$testapi::serialdev";
    assert_script_run "grep '^${serial_group}:.*:${sapadmin}\$' /etc/group || (chown $sapadmin /dev/$testapi::serialdev && gpasswd -a $sapadmin $serial_group)";
}

sub fix_path {
    my ($self, $var) = @_;
    my ($proto, $path) = split m|://|, $var;
    my @aux = split '/', $path;

    $proto = 'cifs' if ($proto eq 'smb' or $proto eq 'smbfs');
    die 'Currently only supported protocols are nfs and smb/smbfs/cifs'
      unless ($proto eq 'nfs' or $proto eq 'cifs');

    $aux[0] .= ':' if ($proto eq 'nfs');
    $aux[0] = '//' . $aux[0] if ($proto eq 'cifs');
    $path = join '/', @aux;
    return ($proto, $path);
}

sub set_ps_cmd {
    my ($self, $procname) = @_;
    $ps_cmd = 'ps auxw | grep ' . $procname . ' | grep -vw grep';
    return $ps_cmd;
}

sub set_sap_info {
    my ($self, $sid_env, $instance_env) = @_;
    $sid      = uc($sid_env);
    $instance = $instance_env;
    $sapadmin = lc($sid_env) . 'adm';
    return ($sapadmin);
}

sub user_change {
    # Allow SAP Admin user to inform status via $testapi::serialdev
    # Note: need to be keep here and during product installation to
    #       ensure compatibility with older generated images
    ensure_serialdev_permissions_for_sap;

    # Change to SAP Admin user
    type_string "su - $sapadmin\n";

    # Change the working shell to bash as SAP's installer sets the admin
    # user's shell to /bin/csh and csh has problems with strings that start
    # with ~ which can be generated by testapi::hashed_string() leading to
    # unexpected failures of script_output() or assert_script_run()
    type_string "exec bash\n";

    # We need to change the 'serial_term_prompt' value for 'wait_serial'
    my $serial_term_prompt = "$sapadmin> ";
    type_string(qq/PS1="$serial_term_prompt"\n/);
    wait_serial(qr/PS1="$serial_term_prompt"/);
    $testapi::distri->{serial_term_prompt} = "$serial_term_prompt";
}

sub reset_user_change {
    # Close the window
    type_string "exit\n";

    # Reset 'serial_term_prompt' value for 'wait_serial'
    $testapi::distri->{serial_term_prompt} = '# ';

    # Rollback changes to $testapi::serialdev
    ensure_serialdev_permissions;
}

sub get_total_mem {
    return get_required_var('QEMURAM') if (check_var('BACKEND', 'qemu'));
    my $mem = script_output q@grep ^MemTotal /proc/meminfo | awk '{print $2}'@;
    $mem /= 1024;
    return $mem;
}

sub is_saptune_installed {
    my $ret = script_run "rpm -q saptune";
    return (defined $ret and $ret == 0);
}

sub is_nw_profile {
    my $list = script_output "tuned-adm list";
    return ($list =~ /sap-netweaver/);
}

sub prepare_profile {
    my ($self, $profile) = @_;
    return unless ($profile eq 'HANA' or $profile eq 'NETWEAVER');

    # Will prepare system with saptune only if it's available.
    # Otherwise will try to use the tuned 'sap-netweaver' profile
    # for netweaver and the recommended one for hana
    my $has_saptune = $self->is_saptune_installed();

    if ($has_saptune) {
        assert_script_run "tuned-adm profile saptune";
        assert_script_run "saptune solution apply $profile";
    }
    elsif ($profile eq 'NETWEAVER') {
        $profile = $self->is_nw_profile() ? 'sap-netweaver' : '$(tuned-adm recommend)';
        assert_script_run "tuned-adm profile $profile";
    }
    elsif ($profile eq 'HANA') {
        assert_script_run 'tuned-adm profile $(tuned-adm recommend)';
    }

    if (!$has_saptune) {
        # Restart systemd-logind to ensure that all new connections will have the
        # SAP tuning activated. Since saptune v2, the call to 'saptune solution apply'
        # above can make the SUT change focus to the x11 console, which may not be ready
        # for the systemctl command. If the systemctl command times out, change to
        # root-console and try again. Run the first call to systemctl with
        # ignore_failure => 1 to avoid stopping the test. Second call runs as usual
        my $ret = systemctl('restart systemd-logind.service', ignore_failure => 1);
        die "systemctl restart systemd-logind.service failed with retcode: [$ret]" if $ret;
        if (!defined $ret) {
            $self->select_serial_terminal;
            systemctl 'restart systemd-logind.service';
        }
    }

    # X11 workaround only on ppc64le
    if (get_var('OFW')) {
        # 'systemctl restart systemd-logind' is causing the X11 console to move
        # out of tty2 on SLES4SAP-15, which in turn is causing the change back to
        # the previous console in post_run_hook() to fail when running on systems
        # with DESKTOP=gnome, which is a false positive as the test has already
        # finished by that step. The following prevents post_run_hook from attempting
        # to return to the console that was set before this test started. For more
        # info on why X is running in tty2 on SLES4SAP-15, see bsc#1054782
        $prev_console = undef;

        # If running in DESKTOP=gnome, systemd-logind restart may cause the graphical console to
        # reset and appear in SUD, so need to select 'root-console' again
        assert_screen(
            [
                qw(root-console displaymanager displaymanager-password-prompt generic-desktop
                  text-login linux-login started-x-displaymanager-info)
            ], 120);
        $self->select_serial_terminal unless (match_has_tag 'root-console');
    }
    else {
        # If running in DESKTOP=gnome, systemd-logind restart may cause the graphical
        # console to reset and appear in SUD, so need to select 'root-console' again
        # 'root-console' can be re-selected safely even if DESKTOP=textmode
        $self->select_serial_terminal;
    }

    if ($has_saptune) {
        assert_script_run "saptune daemon start";
        my $ret = script_run "saptune solution verify $profile";
        if (!defined $ret) {
            # Command timed out. 'saptune daemon start' could have caused the SUT to
            # move out of root-console, so select root-console and try again
            $self->select_serial_terminal;
            $ret = script_run "saptune solution verify $profile";
        }
        record_soft_failure("poo#57464: 'saptune solution verify' returned warnings or errors! Please check!")
          if $ret;

        my $output = script_output "saptune daemon status", proceed_on_failure => 1;
        if (!defined $output) {
            # Command timed out or failed. 'saptune solution verify' could have caused
            # the SUT to move out of root-console, so select root-console and try again
            $self->select_serial_terminal;
            $output = script_output "saptune daemon status";
        }
        record_info("tuned status", $output);
    }
    else {
        assert_script_run "systemctl restart tuned";
    }

    my $output = script_output "tuned-adm active";
    record_info("tuned profile", $output);
}

sub copy_media {
    my ($self, $proto, $path, $nettout, $target) = @_;

    # First copy media
    my $mnt_path = '/mnt';
    assert_script_run "mkdir $target";
    assert_script_run "mount -t $proto -o ro $path $mnt_path";
    type_string "cd $mnt_path\n";
    type_string "cd " . get_var('ARCH') . "\n";    # Change to ARCH specific subdir if exists
    assert_script_run "cp -ax . $target/", $nettout;

    # Go back to target directory and umount the share, as we don't need it anymore
    type_string "cd $target\n";
    assert_script_run "umount $mnt_path";

    # Then verify everything was copied correctly
    # NOTE: checksum is generated with this command: "find . -type f -exec md5sum {} \; > checksums.md5sum"
    my $chksum_file = 'checksum.md5sum';
    # We can't check the checksum file itself as well as the clustered NFS share part
    assert_script_run "sed -i -e '/$chksum_file\$/d' -e '/\\/nfs_share/d' $chksum_file";
    assert_script_run "md5sum -c --quiet $chksum_file", $nettout;
}

sub add_hostname_to_hosts {
    my $netdevice = get_var('SUT_NETDEVICE', 'eth0');
    assert_script_run "echo \$(ip -4 addr show dev $netdevice | sed -rne '/inet/s/[[:blank:]]*inet ([0-9\\.]*).*/\\1/p') \$(hostname) >> /etc/hosts";
}

sub test_pids_max {
    # UserTasksMax should be set to "infinity" in /etc/systemd/logind.conf.d/sap.conf
    my $uid = script_output "id -u $sapadmin";
    # The systemd-run command generates syslog output that may end up in the console, so save the output to a file
    assert_script_run "systemd-run --slice user -qt su - $sapadmin -c 'cat /sys/fs/cgroup/pids/user.slice/user-${uid}.slice/pids.max' | tr -d '\\r' | tee /tmp/pids-max";
    my $rc1 = script_run "grep -qx max /tmp/pids-max";
    # nproc should be set to "unlimited" in /etc/security/limits.d/99-sapsys.conf
    # Check that nproc * 2 + 1 >= threads-max
    assert_script_run "systemd-run --slice user -qt su - $sapadmin -c 'ulimit -u' -s /bin/bash | tr -d '\\r' > /tmp/nproc";
    assert_script_run "cat /tmp/nproc ; sysctl -n kernel.threads-max";
    my $rc2 = script_run "[[ \$(( \$(< /tmp/nproc) * 2 + 1)) -ge \$(sysctl -n kernel.threads-max) ]]";
    record_soft_failure "bsc#1031355" if ($rc1 or $rc2);
}

sub test_forkbomb {
    my $script = 'forkbomb.pl';
    assert_script_run "curl -f -v " . autoinst_url . "/data/sles4sap/$script -o /tmp/$script; chmod +x /tmp/$script";
    # The systemd-run command generates syslog output that may end up in the console, so save the output to a file
    assert_script_run "systemd-run --slice user -qt su - $sapadmin -c /tmp/$script | tr -d '\\r' > /tmp/user-procs", 600;
    my $user_procs = script_output "cat /tmp/user-procs";
    my $root_procs = script_output "/tmp/$script", 600;
    # Check that the SIDadm user can create at least 99% of the processes root could create
    record_soft_failure "bsc#1031355" if ($user_procs < $root_procs * 0.99);
}

sub test_version_info {
    my $output = script_output "sapcontrol -nr $instance -function GetVersionInfo";
    die "sapcontrol: GetVersionInfo API failed\n\n$output" unless ($output =~ /GetVersionInfo[\r\n]+OK/);
}

sub test_instance_properties {
    my $output = script_output "sapcontrol -nr $instance -function GetInstanceProperties | grep ^SAP";
    die "sapcontrol: GetInstanceProperties API failed\n\n$output" unless ($output =~ /SAPSYSTEM.+SAPSYSTEMNAME.+SAPLOCALHOST/s);

    $output =~ /SAPSYSTEMNAME, Attribute, ([A-Z][A-Z0-9]{2})/m;
    die "sapcontrol: SAP administrator [$sapadmin] does not match with System SID [$1]" if ($1 ne $sid);
}

sub test_stop {
    my ($self) = @_;

    my $output = script_output "sapcontrol -nr $instance -function Stop";
    die "sapcontrol: Stop API failed\n\n$output" unless ($output =~ /Stop[\r\n]+OK/);

    # Check if instance is correctly stopped
    $self->check_instance_state('gray');

    $output = script_output "sapcontrol -nr $instance -function StopService";
    die "sapcontrol: StopService API failed\n\n$output" unless ($output =~ /StopService[\r\n]+OK/);

    # Check if service is correctly stopped
    $self->check_service_state('stop');
}

sub test_start {
    my ($self) = @_;

    my $output = script_output "sapcontrol -nr $instance -function StartService $sid";
    die "sapcontrol: StartService API failed\n\n$output" unless ($output =~ /StartService.+OK/s);

    # Check if service is correctly started
    $self->check_service_state('start');

    # Process can take some time to initialize all
    sleep 10;
    $self->check_instance_state('gray');

    $output = script_output "sapcontrol -nr $instance -function Start";
    die "sapcontrol: Start API failed\n\n$output" unless ($output =~ /Start[\r\n]+OK/);

    $self->check_instance_state('green');

    # Show list of processes
    script_run $ps_cmd;
}

sub check_service_state {
    my ($self, $state) = @_;
    my $uc_state = uc $state;

    my $time_to_wait = get_var('WAIT_INSTANCE_STOP_TIME', 300);    # Wait by default for 5 minutes
    $time_to_wait = 600 if ($time_to_wait > 600);                  # Limit this to 10 minutes max

    while ($time_to_wait > 0) {
        my $output = script_output "pgrep -a sapstartsrv | grep -w $sid", proceed_on_failure => 1;
        my @olines = split(/\n/, $output);

        # Exit if there is no more process
        last if ((@olines == 0) && ($uc_state eq 'STOP'));

        if (($output =~ /sapstartsrv/) && ($uc_state eq 'START')) {
            die "sapcontrol: wrong number of processes running after a StartService\n\n" . @olines unless ((@olines == 1) || ($time_to_wait > 10));

            # Exit if service is started
            last;
        }

        $time_to_wait -= 10;
        sleep 10;
    }

    die "Timed out waiting for SAP service status to turn $state" unless ($time_to_wait > 0);
}

sub check_instance_state {
    my ($self, $state) = @_;
    my $uc_state = uc $state;

    my $time_to_wait = get_var('WAIT_INSTANCE_STOP_TIME', 300);    # Wait by default for 5 minutes
    $time_to_wait = 600 if ($time_to_wait > 600);                  # Limit this to 10 minutes max

    while ($time_to_wait > 0) {
        my $output = script_output "sapcontrol -nr $instance -function GetSystemInstanceList";
        die "sapcontrol: GetSystemInstanceList: command failed" unless ($output =~ /GetSystemInstanceList[\r\n]+OK/);

        # Exit if instance is not running anymore
        last if (($output =~ /GRAY/) && ($uc_state eq 'GRAY'));

        if (($output =~ /GREEN/) && ($uc_state eq 'GREEN')) {
            $output = script_output "sapcontrol -nr $instance -function GetProcessList | egrep -i ^[a-z]", proceed_on_failure => 1;
            die "sapcontrol: GetProcessList: command failed" unless ($output =~ /GetProcessList[\r\n]+OK/);

            my $failing_services = 0;
            for my $line (split(/\n/, $output)) {
                next if ($line =~ /GetProcessList|OK|^name/);
                $failing_services++ if ($line !~ /GREEN/);
            }
            last unless $failing_services;
        }

        $time_to_wait -= 10;
        sleep 10;
    }

    die "Timed out waiting for SAP instance status to turn $uc_state" unless ($time_to_wait > 0);
}

sub reboot {
    my ($self) = @_;

    if (check_var('BACKEND', 'ipmi')) {
        power_action('reboot', textmode => 1, keepconsole => 1);
        switch_from_ssh_to_sol_console;
        $self->wait_boot(textmode => 1);
    }
    else {
        power_action('reboot', textmode => 1);
        $self->wait_boot;
    }
    $self->select_serial_terminal;
}

sub post_run_hook {
    my ($self) = @_;

    return unless ($prev_console);
    select_console($prev_console, await_console => 0);
    ensure_unlocked_desktop if ($prev_console eq 'x11');
}

sub post_fail_hook {
    my ($self) = @_;
    $self->select_serial_terminal;
    $self->SUPER::post_fail_hook;
}

1;

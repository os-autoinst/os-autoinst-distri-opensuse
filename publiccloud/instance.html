<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>lib/publiccloud/instance.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel='stylesheet' href='../style.css' />
</head>

<body>



<ul id="index"><li><a href="../index.html"><i>&lt;= Back to file list</i></a></li>
  <li>
    <ul>
      <li><a href="#run_ssh_command">run_ssh_command</a></li>
      <li><a href="#retry_ssh_command">retry_ssh_command</a></li>
      <li><a href="#apply_cmd_timeout-_apply_cmd_timeout-args-ssh_cmd---wraps-ssh_cmd-within-timeout-call-which-will-make-sure-graceful-and-unconditional-interruption-after-defined-period-of-time">_apply_cmd_timeout _apply_cmd_timeout($args, $ssh_cmd) - wraps $ssh_cmd within timeout call which will make sure graceful and unconditional interruption after defined period of time</a></li>
      <li><a href="#ssh_script_run">ssh_script_run</a></li>
      <li><a href="#ssh_assert_script_run">ssh_assert_script_run</a></li>
      <li><a href="#ssh_script_output">ssh_script_output</a></li>
      <li><a href="#ssh_script_retry">ssh_script_retry</a></li>
      <li><a href="#scp">scp</a></li>
      <li><a href="#upload_log">upload_log</a></li>
      <li><a href="#upload_check_logs_tar">upload_check_logs_tar</a></li>
      <li><a href="#wait_for_guestregister">wait_for_guestregister</a></li>
      <li><a href="#update_instance_ip">update_instance_ip</a></li>
      <li><a href="#wait_for_ssh">wait_for_ssh</a></li>
      <li><a href="#isok">isok</a></li>
      <li><a href="#softreboot">softreboot</a></li>
      <li><a href="#stop">stop</a></li>
      <li><a href="#start">start</a></li>
      <li><a href="#get_state">get_state</a></li>
      <li><a href="#network_speed_test">network_speed_test</a></li>
      <li><a href="#measure_boottime">measure_boottime</a></li>
      <li><a href="#store_boottime_db">store_boottime_db</a></li>
    </ul>
  </li>
</ul><h1>lib/publiccloud/instance.pm</h1>

<h2 id="run_ssh_command">run_ssh_command</h2>

<pre><code>run_ssh_command(cmd =&gt; &#39;command&#39;[, timeout =&gt; 90][, ssh_opts =&gt;&#39;..&#39;][, username =&gt; &#39;XXX&#39;][, no_quote =&gt; 0][, rc_only =&gt; 0]);</code></pre>

<p>Runs a command <code>cmd</code> via ssh in the given VM. Retrieves the output. If the command retrieves not zero, an exception is thrown. Timeout can be set by <code>timeout</code> or 90 sec by default. <code>&lt;proceed_on_failure=</code>1&gt;&gt; allows to proceed with validation when <code>cmd</code> is failing (return non-zero exit code) By default, the command is passed in single quotes to SSH. To avoid quoting use <code>&lt;no_quote=</code>1&gt;&gt;. With <code>&lt;ssh_opts=</code>&#39;...&#39;&gt;&gt; you can overwrite all default ops which are in <code>&lt;$instance-</code>ssh_opts&gt;&gt;. Use argument <code>username</code> to specify a different username then <code>&lt;$instance-</code>username()&gt;&gt;. Use argument <code>rc_only</code> to only check for the return code of the command.</p>

<h2 id="retry_ssh_command">retry_ssh_command</h2>

<pre><code>ssh_script_retry(command[, retry =&gt; 3][, delay =&gt; 10][, timeout =&gt; 90][, ssh_opts =&gt;&#39;..&#39;][, username =&gt; &#39;XXX&#39;][, no_quote =&gt; 0]);</code></pre>

<p>Run a <code>command</code> via ssh in the given PC instance until it succeeds or the given number of retries is exhausted and an exception is thrown. Timeout can be set by <code>timeout</code> or 90 sec by default. By default, the command is passed in single quotes to SSH. To avoid quoting use <code>&lt;no_quote=</code>1&gt;&gt;. With <code>&lt;ssh_opts=</code>&#39;...&#39;&gt;&gt; you can overwrite all default ops which are in <code>&lt;$instance-</code>ssh_opts&gt;&gt;. Use argument <code>username</code> to specify a different username then <code>&lt;$instance-</code>username()&gt;&gt;.</p>

<p>This function is deprecated. Please use ssh_script_retry instead.</p>

<h2 id="apply_cmd_timeout-_apply_cmd_timeout-args-ssh_cmd---wraps-ssh_cmd-within-timeout-call-which-will-make-sure-graceful-and-unconditional-interruption-after-defined-period-of-time">_apply_cmd_timeout _apply_cmd_timeout($args, $ssh_cmd) - wraps $ssh_cmd within timeout call which will make sure graceful and unconditional interruption after defined period of time</h2>

<pre><code>C&lt;args&gt; - reference to args hash. it is important to pass reference so function can modify timeout passed to script_run by the caller
            to make sure it is bigger than value defined in timeout command which suppose to kill what script_run needs to execute
C&lt;ssh_cmd&gt; - reference to string containing command which will be executed by script_run. function will tweak it to include timeout call
            which will kill underlying command after time defined by args{timeout}</code></pre>

<h2 id="ssh_script_run">ssh_script_run</h2>

<pre><code>ssh_script_run($cmd [, timeout =&gt; $timeout] [,quiet =&gt; $quiet] [,ssh_opts =&gt; $ssh_opts] [,username =&gt; $username][, ignore_timeout_failure =&gt; $ignore_timeout_failure])

C&lt;timeout&gt; - TTL for command execution measured in seconds . After that period of time execution will be aborded
C&lt;quiet&gt; - avoid recording serial_results ( value pass to script_run call)
C&lt;ssh_opts&gt; - additional ssh options passed to ssh
C&lt;username&gt; - username used for ssh tunnel
C&lt;ignore_timeout_failure&gt; - in case waiting longer than timeout normally script_run will die. Setting this parameter to true
    will avoid such failure</code></pre>

<p>Runs a command <code>cmd</code> via ssh on the publiccloud instance and returns the return code.</p>

<h2 id="ssh_assert_script_run">ssh_assert_script_run</h2>

<pre><code>ssh_assert_script_run($cmd [, timeout =&gt; $timeout] [, fail_message =&gt; $fail_message] [,quiet =&gt; $quiet] [,ssh_opts =&gt; $ssh_opts] [,username =&gt; $username])</code></pre>

<p>Runs a command <code>cmd</code> via ssh on the publiccloud instance and die, unless it returns zero.</p>

<h2 id="ssh_script_output">ssh_script_output</h2>

<pre><code>ssh_script_output($script [, $wait, type_command =&gt; 1, proceed_on_failure =&gt; 1] [,quiet =&gt; $quiet] [,ssh_opts =&gt; $ssh_opts] [,username =&gt; $username])</code></pre>

<p>Executing script inside SUT with bash -eo and directs stdout (but not stderr!) to the serial console and returns the output if the script exits with 0. Otherwise the test is set to failed.</p>

<h2 id="ssh_script_retry">ssh_script_retry</h2>

<pre><code>ssh_script_retry($cmd, [expect =&gt; $expect], [retry =&gt; $retry], [delay =&gt; $delay], [timeout =&gt; $timeout], [die =&gt; $die] [,ssh_opts =&gt; $ssh_opts] [,username =&gt; $username])</code></pre>

<p>Repeat command until expected result or timeout.</p>

<h2 id="scp">scp</h2>

<pre><code>scp($from, $to[, timeout =&gt; 90]);</code></pre>

<p>Use scp to copy a file from or to this instance. A url starting with <code>remote:</code> is replaced with the IP from this instance. E.g. a call to copy the file <i>/var/log/cloudregister</i> to <i>/tmp</i> looks like: <code>&lt;&lt;$instance-</code>scp(&#39;remote:/var/log/cloudregister&#39;, &#39;/tmp&#39;);&gt;&gt;&gt;</p>

<h2 id="upload_log">upload_log</h2>

<pre><code>upload_log($filename);</code></pre>

<p>Upload a file from this instance to openqa using <a>upload_logs()</a>. If the file doesn&#39;t exists on the instance, <b>no</b> error is thrown.</p>

<h2 id="upload_check_logs_tar">upload_check_logs_tar</h2>

<pre><code>upload_check_logs_tar(@files);</code></pre>

<p>Check remote log files status and upload tar.gz of only ok logs, to oqa UI.</p>

<p>Input: <code>@files</code> full-path-files array;</p>

<p>Return <code>1</code> true explicit, as stateless and never impact calling code.</p>

<h2 id="wait_for_guestregister">wait_for_guestregister</h2>

<pre><code>wait_for_guestregister([timeout =&gt; 300]);</code></pre>

<p>Run command <code>systemctl is-active guestregister</code> on the instance in a loop and wait till guestregister is ready. If guestregister finish with state failed, a soft-failure will be recorded. If guestregister will not finish within <code>timeout</code> seconds, job dies. In case of BYOS images we checking that service is inactive and quit Returns the time needed to wait for the guestregister to complete.</p>

<h2 id="update_instance_ip">update_instance_ip</h2>

<pre><code>update_instance_ip(timeout =&gt; 600)</code></pre>

<p>This subroutine checks the public IP cloud provider provides for the VM. When the IP differs from `$self-&gt;public_ip` we update `$self-&gt;public_ip`.</p>

<h2 id="wait_for_ssh">wait_for_ssh</h2>

<pre><code>wait_for_ssh([timeout =&gt; 600] [, proceed_on_failure =&gt; 0] [, scan_ssh_host_key =&gt; 0] [, ...])</code></pre>

<p>When a remote pc instance starting, by default wait_stop param.=0(false) and this routine checks until the SSH port of the remote instance is reachable and open. Then by default also checks that system is up, unless systemup_check false/0.</p>

<p>Wnen a remote pc instance is stopping in shutdown, we set input param. wait_stop=1(true), to expect until ssh is closed; automatic defaults systemup_check=0 and proceed_on_failure=1 applied. Status values of exit_code: 0 = pass; 1 = fail; 2 = fail,but retry,till timeout or valid outcome.</p>

<p>Parameters: timeout =&gt; total wait timeout; default: 600. wait_stop =&gt; If true waits for ssh port to become unreachable, if false waits for ssh reachable; default: false. proceed_on_failure =&gt; in case of fail, if false exit test with error, if true let calling code to continue; default: wait_stop. scan_ssh_host_key =&gt; If true we will rescan the SSH host key This will be true when: * SUT changes it&#39;s public IP address * SUT regenerates it&#39;s SSH host keys (e.g. when cloud-init state is cleared) username =&gt; default: username(). systemup_check =&gt; If true, checks if the system is up too, instead of just checking the ssh port; default: !wait_stop. logs =&gt; If true, upload journal to test logs, if false log not uploaded, to speed up check; default: true.</p>

<p>Return: duration if pass undef if fail and proceed_on_failure true, otherwise die.</p>

<h2 id="isok">isok</h2>

<pre><code>isok($exit_code);</code></pre>

<p>To convert in a true or 1 value for perl tests the exit_code 0 of shell script ok.</p>

<p>Return: the positive test status of a shell exit code, that is true(1) and ok when its value is defined and zero: <code>$x == 0</code> otherwise false(undef).</p>

<h2 id="softreboot">softreboot</h2>

<pre><code>($shutdown_time, $bootup_time) = softreboot([timeout =&gt; 600] [, scan_ssh_host_key =&gt; ?]);</code></pre>

<p>Does a softreboot of the instance by running the command <code>shutdown -r</code>. Return an array of two values, first one is the time till the instance isn&#39;t reachable anymore. The second one is the estimated bootup time.</p>

<h2 id="stop">stop</h2>

<pre><code>stop();</code></pre>

<p>Stop the instance using the CSP api calls.</p>

<h2 id="start">start</h2>

<pre><code>start([timeout =&gt; ?] [, scan_ssh_host_key =&gt; ?]);</code></pre>

<p>Start the instance and wait for the system to be up. Returns the number of seconds till the system up and running.</p>

<h2 id="get_state">get_state</h2>

<pre><code>get_state();</code></pre>

<p>Get the status of the instance using the CSP api calls.</p>

<h2 id="network_speed_test">network_speed_test</h2>

<pre><code>network_speed_test();</code></pre>

<p>Test the network speed.</p>

<h2 id="measure_boottime">measure_boottime</h2>

<pre><code>measure_boottime();</code></pre>

<p>Perfomrance measurement of the system Boot time. Mainly used <code>systemd-analyze</code> command for the data extraction. Data is then collected in an internal record, ready for storing in a DB. Set PUBLIC_CLOUD_PERF_COLLECT true or &gt;0, to activate boottime measurements.</p>

<h2 id="store_boottime_db">store_boottime_db</h2>

<pre><code>store_boottime_db();</code></pre>

<p>Save data collected with measure_boottime in a DB; Mainly stored on a remote InfluxDB on a Grafana server. To activate boottime push, shall be available results and PUBLIC_CLOUD_PERF_PUSH_DATA true/not 0 and _SECRET_PUBLIC_CLOUD_PERF_DB_TOKEN defined</p>


</body>

</html>


